{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"optio",
				"optionsClass"
			],
			[
				"en",
				"env"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "#\n# (C) 2001-2013 Marmalade. All Rights Reserved.\n#\n# This document is protected by copyright, and contains information\n# proprietary to Marmalade.\n#\n# This file consists of source code released by Marmalade under\n# the terms of the accompanying End User License Agreement (EULA).\n# Please do not use this program/source code before you have read the\n# EULA and have agreed to be bound by its terms.\n#\n# TODO: add a note that original code has been modified\n#\n#no_template_code\ncallbacks\n#no_init_term\n\ninclude:\n\n#include \"s3eTypes.h\"\n\n/**\n * @addtogroup s3egroup\n * @{\n */\n\n/**\n * @defgroup openiabgroup S3E OpenIAB API reference\n *\n * Provides an API for making in-app purchases through the Google Play store V3 interface\n * for different stores.\n *\n * @supported\n * - android\n *\n * @platnote This API is for Android only. For the equivalent in-app billing\n * API for iOS, see \"S3E iOS App Store Billing\".\n *\n *\n * TODO: implement for iOS\n *\n * TODO: add reference to the documentation\n */\n\n/**\n * @}\n * @addtogroup openiabgroup\n * @{\n */\n \n /**\n *  OpenIAB callbacks\n *	Note In Marmalade all callbacks are queued up and trigger after the next s3eDeviceYield()\n *	\n *	Your callback needs to be of the form int32 MyCallback(void *systemData,void *userData)\n *  systemData is data from the store and needs to be cast to the appropriate structure - see the \"systemdata points to\" comments below.\n *	userData is specified when you register the callback, it is simply passed back to your callback and could be used to help the callback identify context (eg. it could be a pointer to a class you need to pass the data to)\n *  You register the callback using eg. s3eOpenIabRegister(S3E_OPENIAB_PURCHASE_CALLBACK, myPurchaseCallback, this);\n *	The return value is always ignored.\n */\n\nenum s3eOpenIabCallback\n{\n     /**\n     * Called when a purchase attempt completes with an outcome. \n	 * @see s3eOpenIabRequestPurchase.\n	 * If the purchase was successful and was for a consumable good, you *MUST* now call s3eOpenIabConsumeItem or the item will not be available for purchase again.\n     * systemdata points to a s3eOpenIabPurchaseResponse\n	 * @see s3eOpenIabPurchaseResponse\n     */\n    S3E_OPENIAB_PURCHASE_CALLBACK,\n	\n	/**\n	* Called with a list of products that are availabe in the store.\n	* @see s3eOpenIabRequestProductInformation\n	* systtemdata points to a s3eOpenIabSkuResponse\n	* @see s3eOpenIabSkuResponse\n	*/\n	\n	S3E_OPENIAB_LIST_PRODUCTS_CALLBACK,\n	\n	/** Called with a list of products the user has previously purchased.\n	* @see 3eOpenIabRestoreTransactions\n	* systemdata points to a s3eOpenIabRestoreResponse\n	* @see s3eOpenIabRestoreResponse\n	*/\n	\n	S3E_OPENIAB_RESTORE_CALLBACK,\n	\n	/**\n	* Called with the result of a Consume request. \n	* @see s3eOpenIabConsumeItem\n	* systemdata points to a s3eOpenIabConsumeResponse\n	* @see s3eOpenIabConsumeResponse\n	*/\n	S3E_OPENIAB_CONSUME_CALLBACK,\n\n    /**\n     * The number of in-app billing callbacks. Required by S3E.\n     */\n    S3E_OPENIAB_CALLBACK_MAX\n};\n\n/**\n * The possible error codes from s3eOpenIab functions, these error codes are used across all the callbacks\n */\nenum s3eOpenIabResult\n{\n    /** Success */\n    S3E_OPENIAB_RESULT_OK = 0,\n\n    /** User pressed back or cancelled a dialog */\n    S3E_OPENIAB_RESULT_USER_CANCELED = 1,\n\n    /** This billing API version is not supported for the type requested */\n    S3E_OPENIAB_RESULT_BILLING_UNAVAILABLE = 3,\n\n    /** Requested product is not available for purchase  */\n    S3E_OPENIAB_RESULT_ITEM_UNAVAILABLE = 4,\n\n    /** Invalid arguments provided to the API. This error can also indicate that the application was not correctly signed or properly set up for In-app Billing in Google Play, or does not have the necessary permissions in its manifest */\n    S3E_OPENIAB_RESULT_DEVELOPER_ERROR = 5,\n\n    /** Fatal error during the API action */\n    S3E_OPENIAB_RESULT_ERROR = 6,\n\n    /** Failure to purchase since item is already owned - make sure you called s3eOpenIabConsumeItem */\n    S3E_OPENIAB_RESULT_ITEM_ALREADY_OWNED = 7,\n\n    /** Failure to consume since item is not owned */\n    S3E_OPENIAB_RESULT_ITEM_NOT_OWNED = 8,\n	\n	/** Set of error conditions internal to the extension  */\n	\n    S3E_OPENIAB_REMOTE_EXCEPTION = -1001,\n	\n    S3E_OPENIAB_BAD_RESPONSE = -1002,\n	\n	/** The security checks using your public certificate failed */\n    S3E_OPENIAB_VERIFICATION_FAILED = -1003,\n	\n    S3E_OPENIAB_SEND_INTENT_FAILED = -1004,\n	\n    S3E_OPENIAB_USER_CANCELLED = -1005,\n	\n    S3E_OPENIAB_UNKNOWN_PURCHASE_RESPONSE = -1006,\n	\n    S3E_OPENIAB_MISSING_TOKEN = -1007,\n	\n    S3E_OPENIAB_UNKNOWN_ERROR = -1008,\n	\n    S3E_OPENIAB_SUBSCRIPTIONS_NOT_AVAILABLE = -1009,\n	\n    S3E_OPENIAB_INVALID_CONSUMPTION = -1010\n};\n\n/**\n * OpenIAB public keys verification mode\n */\nenum s3eOpenIabVerifyMode\n{\n	/**\n	 * Verify signatures in any store. \n	 * This is set by default in Google's IabHelper. Throws exception if key is not available or invalid.\n	 * To prevent crashes OpenIAB wouldn't connect to OpenStore if no publicKey provided\n	 */\n	VERIFY_EVERYTHING = 0,\n\n	/** Don't verify signatires. To perform verification on server-side */\n	VERIFY_SKIP = 1,\n\n	/** Verify signatures only if publicKey is available. Otherwise skip verification. */\n	VERIFY_ONLY_KNOWN = 2\n};\n\nenum SamsungRequestCode\n{\n	REQUEST_CODE_IS_IAP_PAYMENT = 1,\n	REQUEST_CODE_IS_ACCOUNT_CERTIFICATION = 899\n};\n\n/** OpenIAB options structure **/\nstruct s3eOpenIabOptions\n{\n	/** Wait specified amount of ms to find all OpenStores on device. 5000 by default */\n	int m_DiscoveryTimeoutMs;\n	\n	/** \n	 * Check user inventory in every store to select proper store\n	 * Will try to connect to each billingService and extract user's purchases.\n	 * If purchases have been found in the only store that store will be used for further purchases. \n	 * If purchases have been found in multiple stores only such stores will be used for further elections    \n	 */\n	bool m_CheckInventory;\n	\n	/** Wait specified amount of ms to check inventory in all stores. 10000 by default */\n	int m_CheckInventoryTimeoutMs;\n\n	s3eOpenIabVerifyMode m_VerifyMode;\n	\n	/** Store 'public key' keys */\n	const char** m_StoreNames;\n	\n	/** Store 'public key' values */\n	const char** m_StoreKeys;\n	\n	int m_NumStores;\n	\n    /**\n	 * Used as priority list if store that installed app is not found and there are \n     * multiple stores installed on device that supports billing.\n     */\n	const char** m_PrefferedStoreNames;\n	\n	int m_NumPrefferedStoreNames;\n\n    /** \n     * Used for SamsungApps setup. Specify your own value if default one interfere your code.\n     * default value is SamsungRequestCode::REQUEST_CODE_IS_ACCOUNT_CERTIFICATION\n     */\n	int m_SamsungCertificationRequestCode;\n};\n\nstruct s3eOpenIabStoreNames\n{\n	char* m_GooglePlay;\n	char* m_Amazon;\n	char* m_Tizen;\n	char* m_Samsung;\n	\n	// TODO:\n	/* char* m_AppStore; */\n};\n\n/** Structure detailing a purchase that has been made, used in both s3eOpenIabPurchase and s3eOpenIabRestoreResponse */\n\nstruct s3eOpenIabPurchase\n{\n    /** A unique order identifier for the transaction. This corresponds to the Google Wallet Order ID. */\n    char* m_OrderID;\n    /** The application package from which the purchase originated. */\n    char*    m_PackageID;\n    /** The item's product identifier. Every item has a product ID, which you must specify in the application's product list on the Google Play Developer Console. */\n    char*    m_ProductId;\n    /** Time item was purchased. [since epoch, Jan 1st 1970] */\n    unsigned int m_PurchaseTime;\n    /** The purchase state of the order. Possible values are 0 (purchased), 1 (canceled), or 2 (refunded). */\n    int		m_PurchaseState;\n    /** A token that uniquely identifies a purchase for a given item and user pair.  */\n    char*	m_PurchaseToken;\n	/** A developer-specified string that contains supplemental information about an order. You can specify a value for this field when you make a s3eOpenIabRequestPurchase request. */\n    char*	m_DeveloperPayload;\n	/** The raw JSON string sent from Google */\n	char*	m_JSON;\n	/** The signature of the JSON string - this has already been checked by this extension, however you may want to perform additional checks */	\n	char* 	m_Signature;\n	\n	char*   m_AppstoreName;\n};\n\n/**\n * Structure passed to your S3E_OPENIAB_PURCHASE_CALLBACK\n * @see s3eOpenIabRequestPurchase\n * @par Required Header Files\n * s3eOpenIab.h\n */\n\nstruct s3eOpenIabPurchaseResponse\n{\n	/** informational message to assist during development, may not be set, also see device logs */\n	char *m_ErrorMsg;\n	/** outcome of the purchase, if the result is S3E_OPENIAB_RESULT_OK then m_PurchaseDetails below will be be set */\n	s3eOpenIabResult m_Status;\n\n	/** Details of the purchase, will be null if purchase failed */\n	s3eOpenIabPurchase *m_PurchaseDetails; \n};\n\n/**\n * One of the available products listed in your shop, used in the s3eOpenIabSkuResponse\n */\nstruct s3eOpenIabItemInfo\n{\n	/** The product ID for the product. */\n    char* 	m_ProductID;\n	/** Value will be �inapp� for an in-app product or \"subs\" for subscription. */\n	char* 	m_Type;\n     /** Formatted price of the item, including its currency sign. The price does not include tax. e.g $5.00  */\n    char*   m_Price;\n	/** Title of the item. */\n    char*	m_Title;\n    /** Description of the product. */\n    char*   m_Description;\n};\n\n/**\n * Structure passed to your S3E_OPENIAB_LIST_PRODUCTS_CALLBACK callback\n * @see s3eOpenIabRequestProductInformation\n * @par Required Header Files\n * s3eOpenIab.h\n */\nstruct s3eOpenIabSkuResponse\n{\n  	/** informational message to assist during development, may not be set, also see device logs */\n	char *m_ErrorMsg;\n	/** outcome of the purchase, if the result is S3E_OPENIAB_RESULT_OK then the fields below will be filled out */\n	s3eOpenIabResult m_Status;\n	\n	/** The number of products in the m_Products array */\n	int m_NumProducts;\n	/** The array of products in this sku */\n	s3eOpenIabItemInfo* m_Products;\n};\n\n/**\n * One of the purchased items, used in s3eOpenIabRestoreResponse\n */\nstruct s3eOpenIabPurchaseInfo\n{\n	/** Name of the sku this product came from */\n	const char* m_Sku;\n	/** details of the purchase made */\n	s3eOpenIabPurchase m_PurchaseDetails;\n};\n\n/**\n * Structure passed to your S3E_OPENIAB_RESTORE_CALLBACK callback\n * @see 3eOpenIabRestoreTransactions\n * @par Required Header Files\n * s3eOpenIab.h\n */\n\nstruct s3eOpenIabRestoreResponse\n{\n  	/** informational message to assist during development, may not be set, also see device logs */\n	char *m_ErrorMsg;\n	/** outcome of the purchase, if the result is S3E_OPENIAB_RESULT_OK then the fields below will be filled out */\n	s3eOpenIabResult m_Status;\n	\n	/** Number of purchases in the m_Purchases array */\n	int m_NumPurchases;\n	/** List of purchases */\n	s3eOpenIabPurchase* m_Purchases;\n};\n\n/**\n * Structure passed to your S3E_OPENIAB_CONSUME_CALLBACK callback\n * @see s3eOpenIabConsumeItem\n * @par Required Header Files\n * s3eOpenIab.h\n */\n\nstruct s3eOpenIabConsumeResponse\n{\n  	/** informational message to assist during development, may not be set, also see device logs */\n	char *m_ErrorMsg;\n	/** outcome of the consumption request, if the result is S3E_OPENIAB_RESULT_OK then the consume request succeeded */\n	s3eOpenIabResult m_Status;\n};\n\nfunctions:\n\n/**\n * Explicitly initialise s3eOpenIab extension.\n * Use s3eOpenIabIsSupported() to check for completion as the startup is asynchronous.\n * @param base64PublicKey, is the base64 version of your public key. Note that this is the application's public key, not the\n *    developer public key that you use with Marmalade. You can find the application's base64 public key in the \"Services & API\" page for your application.\n *\n * TODO: add something about options, not base64 key\n */\nvoid s3eOpenIabStart(s3eOpenIabOptions* options) S3E_RESULT_ERROR run_on_os_thread\n\n/**\n * Terminate s3eOpenIab extension.\n * Important, You should call this function when you're done as an open service connection could degrade the performance of the device.\n */\nvoid s3eOpenIabStop()\n\n/**\n * Checks for the availability of in-app billing with the Google Play application.\n * @return An s3eResult indicating the availability of in-app billing. Note, this will return false until you call s3eOpenIabStart\n */\ns3eResult s3eOpenIabIsSupported() S3E_RESULT_ERROR\n\n/**\n * Initiates the purchase of an item given a product ID \n * You need to register for the S3E_OPENIAB_PURCHASE_CALLBACK callback to determine the outcome of the purchase and award the purchase in your app. \n * For consumable \"inApp\" goods you *MUST* also call s3eOpenIabConsumeItem. Until you do this the item will not be available for purchase again in the store and you will get S3E_OPENIAB_RESULT_ITEM_ALREADY_OWNED\n * Note, for additional security use the purchase developerPayload but make sure it's unique to the purchase and not dependent on the device.\n * Associated callback S3E_OPENIAB_PURCHASE_CALLBACK\n * @param purchaseID [UTF-8 encoded] item ID to be purchased.\n * @param developerPayLoad [UTF-8 encoded] additional arguments that you want Google Play to send back along with the purchase information [Optional]\n * @param inApp - You can set up either \"in app\" type purchases or \"subscription\" based purchases. in app type purchases are consumable, subscription type purchases are not.\n * @return void - the purchase query is asynchronous, use the callback to receive the response.\n */\nvoid s3eOpenIabRequestPurchase(const char* productID, bool inApp, const char* developerPayLoad S3E_DEFAULT(0)) run_on_os_thread\n\n/**\n * Returns details about items available for purchase.\n * Unfortunately it is not possible to blindly enumerate available items so you need to pass two lists of known product IDs, one for \"inApp\" items and one for \"subscription\" items, either list could be empty (or null).\n * You need to register for the S3E_OPENIAB_LIST_PRODUCTS_CALLBACK to receive the response.\n * @param inAppProducts - an array of your const char* \"inApp\" product Ids (skus).\n * @param numInAppProducts - the number of product Ids in the \"inApp\" array.\n * @param subProducts - an array of your const char* \"Subscription\" product Ids (skus).\n * @param numSubProducts - the number of product Ids in the \"Subscription\" array.\n * @return void - the request is asynchronous, use the callback to receive the response.\n */\nvoid s3eOpenIabRequestProductInformation(const char** inAppProducts,int numInAppProducts, const char** subProducts, int numSubProducts) run_on_os_thread\n\n/**\n * Query for purchased items.\n * This method returns the current un-consumed products owned by the user.\n * You need to register for the S3E_OPENIAB_RESTORE_CALLBACK to receive the response\n * The Google Play service returns only the purchases made by the user account that is currently logged in to the device.\n * @return void - the query is asynchronous, use the callback to receive the response.\n */\nvoid s3eOpenIabRestoreTransactions() run_on_os_thread\n\n/**\n * Consumes the purchase of the given \"in app\" (consumable) item such as coins. \n * Note, this consumes the entire purchase, the Store is not responsible for tracking the individual coins.\n * Important, Until you call this function the item will not be available for purchase in the store again.\n * Google recommend your flow is to Consume the item and check the Consume callback response before awarding the goods to the user. \n * It is also good practise to invoke 3eOpenIabRestoreTransactions at discrete points in your app and check for consumable items that you may have missed. \n * Associated callback S3E_OPENIAB_CONSUME_CALLBACK.\n * @param purchaseToken - The m_PurchaseToken of the order you are consuming.\n * @return void - the request is asynchronous, use the callback to receive the response.\n */\nvoid s3eOpenIabConsumeItem(const char* purchaseToken) run_on_os_thread\n\n/**\n * Get names of the stores to use in the Options\n*/\ns3eOpenIabStoreNames* s3eOpenIabGetStoreNames() NULL\n\nvoid s3eOpenIabMapSku(const char* sku, const char* storeName, const char* storeSku);\n\nappend:\n/** @} */\n",
			"file": "/Z/Projects/OpenIAB-fork/marmalade_plugin/s3eOpenIab.s4e",
			"file_size": -1,
			"file_write_time": -1,
			"settings":
			{
				"buffer_size": 16022,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "Don't need to extend BillingActivity anymore.\nNow having org.onepf.openiab.UnityProxyActivity is AndroidManifest.xml is enough for Android.\n\nLots of issues are fixed.",
			"settings":
			{
				"buffer_size": 166,
				"line_ending": "Windows",
				"name": "Don't need to extend BillingActivity anymore."
			}
		},
		{
			"file": "/Z/Projects/OpenIAB-fork/unity_plugin/unity_src/.gitignore",
			"settings":
			{
				"buffer_size": 49,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "/*\njava implementation of the s3eOpenIab extension.\n\nAdd android-specific functionality here.\n\nThese functions are called via JNI from native code.\n*/\n\npackage org.onepf.marmalade.s3eOpenIab;\n\nimport android.content.Intent;\nimport android.util.Log;\nimport com.ideaworks3d.marmalade.LoaderAPI;\nimport org.onepf.oms.OpenIabHelper;\nimport org.onepf.oms.appstore.googleUtils.*;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass s3eOpenIab {\n    private static final String TAG = \"s3eOpenIab\";\n\n    // The helper object\n    public static OpenIabHelper mHelper;\n    private boolean s3eOpenIabAvailable = false;\n    public static boolean m_SendRequest = false;\n\n    public int s3eOpenIabStart(OpenIabHelper.Options options) {\n        Log.d(TAG, \"s3eOpenIabStart called.\");\n        if (options == null) {\n            Log.d(TAG, \"ERROR: No options sent.\");\n            return 1; // S3E_RESULT_ERROR\n        }\n\n        Log.d(TAG, \"Verification mode: \" + options.verifyMode);\n\n        // Create the helper, passing it our context and the options\n        Log.d(TAG, \"Creating IAB helper.\");\n        mHelper = new OpenIabHelper(LoaderAPI.getActivity(), options);\n\n        // Start setup. This is asynchronous and the specified listener\n        // will be called once setup completes.\n        Log.d(TAG, \"Starting setup.\");\n        mHelper.startSetup(new IabHelper.OnIabSetupFinishedListener() {\n            public void onIabSetupFinished(IabResult result) {\n                Log.d(TAG, \"Setup finished.\");\n\n                if (!result.isSuccess()) {\n                    // Oh noes, there was a problem.\n                    Log.d(TAG, \"Problem setting up in-app billing: \" + result);\n                    return;\n                }\n                s3eOpenIabAvailable = true;\n\n                // Hooray, IAB is fully set up. Now, let's get an inventory of stuff we own.\n                Log.d(TAG, \"Setup successful. Querying inventory.\");\n                mHelper.queryInventoryAsync(mGotInventoryListener);\n            }\n        });\n        return 0; // S3E_RESULT_SUCCESS - immediate response\n    }\n\n    public void s3eOpenIabStop() {\n        // very important:\n        Log.d(TAG, \"s3eOpenIabStop called.\");\n        if (mHelper != null) {\n            mHelper.dispose();\n        } else {\n            Log.d(TAG, \"s3eOpenIabStop called without having been successfully started.\");\n        }\n        mHelper = null;\n        s3eOpenIabAvailable = false;\n    }\n\n    public int s3eOpenIabIsSupported() {\n        // this will be converted into an S3E_RESULT , SUCCESS is 0\n        return (s3eOpenIabAvailable) ? 0 : 1;\n    }\n\n    // Callback for when a purchase is finished - note this is static final and so the same listener is used across multiple instances of this class (which shouldn't happen as it's created once by Marmalade)\n    public static final IabHelper.OnIabPurchaseFinishedListener mPurchaseFinishedListener = new IabHelper.OnIabPurchaseFinishedListener() {\n        public void onIabPurchaseFinished(IabResult result, Purchase purchase) {\n            Log.d(TAG, \"Purchase finished: \" + result + \", purchase: \" + purchase);\n            if (result.isFailure()) {\n                safe_native_PURCHASE_CALLBACK(result, null);\n                return;\n            }\n\n            Log.d(TAG, \"Purchase successful.\");\n\n            safe_native_PURCHASE_CALLBACK(result, purchase);\n        }\n    };\n\n    public void s3eOpenIabRequestPurchase(String productID, boolean inApp, String developerPayLoad) {\n        Log.d(TAG, \"s3eOpenIabRequestPurchase called for: \" + productID);\n        if (!s3eOpenIabAvailable) {\n            IabResult err = new IabResult(IabHelper.BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE, \"Android Market Billing is not available, did you call s3eOpenIabStart?\");\n            safe_native_PURCHASE_CALLBACK(err, null);\n            return;\n        }\n        m_SendRequest = true;\n        Intent i = new Intent(LoaderAPI.getActivity(), PurchaseProxy.class);\n        i.putExtra(\"productID\", productID);\n        i.putExtra(\"inApp\", inApp);\n        i.putExtra(\"developerPayLoad\", developerPayLoad);\n\n\n        // launch our Activity inner class - it will close itself down when we have a response\n        LoaderAPI.getActivity().startActivity(i);\n    }\n\n    /**\n     * The IabHelper adopts a rather obtuse approach to combining inventory with purchased products that doesn't\n     * really fit our use pattern, so we've added our own version to the end of IabHelper.\n     */\n\n    public void s3eOpenIabRequestProductInformation(String[] inAppSkus, String[] subSkus) {\n        Log.d(TAG, \"s3eOpenIabRequestProductInformation called for:\");\n        if (inAppSkus != null)\n            Log.d(TAG, \"inApp: \" + inAppSkus.toString());\n        if (subSkus != null)\n            Log.d(TAG, \"subs: \" + subSkus.toString());\n        if (!s3eOpenIabAvailable) {\n            IabResult err = new IabResult(IabHelper.BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE, \"Android Market Billing is not available, did you call s3eOpenIabStart?\");\n            safe_native_LIST_PRODUCTS_CALLBACK(err, null);\n            return;\n        }\n        // kick off the async query\n        List<String> inAppList = null, subsList = null;\n        if (inAppSkus != null)\n            inAppList = Arrays.asList(inAppSkus);\n        if (subSkus != null)\n            subsList = Arrays.asList(subSkus);\n\n        mHelper.queryInventoryAsync(inAppList, subsList, mGotSkusListener);\n    }\n\n    public void s3eOpenIabMapSku(String sku, String storeName, String storeSku) {\n        Log.d(TAG, \"s3eOpenIabMapSku called\");        \n    }    \n\n    // Listener that's called when we finish querying the items and subscriptions we own\n    IabHelper.QueryInventoryFinishedListener mGotSkusListener = new IabHelper.QueryInventoryFinishedListener() {\n        public void onQueryInventoryFinished(IabResult result, Inventory inventory) {\n            Log.d(TAG, \"Query products finished.\");\n            if (result.isFailure()) {\n                safe_native_LIST_PRODUCTS_CALLBACK(result, null);\n                return;\n            }\n\n            Log.d(TAG, \"Query products was successful.\");\n            safe_native_LIST_PRODUCTS_CALLBACK(result, inventory);\n        }\n    };\n\n    public void s3eOpenIabRestoreTransactions() {\n        Log.d(TAG, \"s3eOpenIabRestoreTransactions called.\");\n        if (!s3eOpenIabAvailable) {\n            IabResult err = new IabResult(IabHelper.BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE, \"Android Market Billing is not available, did you call s3eOpenIabStart?\");\n            safe_native_RESTORE_CALLBACK(err, null);\n            return;\n        }\n        // kick off the async query\n        mHelper.queryInventoryAsync(false, null, mGotInventoryListener);\n    }\n\n    // Listener that's called when we finish querying the subscriptions we own\n    IabHelper.QueryInventoryFinishedListener mGotInventoryListener = new IabHelper.QueryInventoryFinishedListener() {\n        public void onQueryInventoryFinished(IabResult result, Inventory inventory) {\n            Log.d(TAG, \"Query inventory finished.\");\n            if (!s3eOpenIabAvailable) {\n                IabResult err = new IabResult(IabHelper.BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE, \"Android Market Billing is not available, did you call s3eOpenIabStart?\");\n                safe_native_RESTORE_CALLBACK(err, null);\n                return;\n            }\n\n            Log.d(TAG, \"Query inventory was successful.\");\n\n            safe_native_RESTORE_CALLBACK(result, inventory);\n        }\n    };\n\n    public void s3eOpenIabConsumeItem(String purchaseToken) {\n        Log.d(TAG, \"s3eOpenIabConsumeItem called for: \" + purchaseToken);\n        if (!s3eOpenIabAvailable) {\n            IabResult err = new IabResult(IabHelper.BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE, \"Android Market Billing is not available, did you call s3eOpenIabStart?\");\n            safe_native_CONSUME_CALLBACK(err);\n            return;\n        }\n        // construct a Purchase the helper is happy with\n        Purchase purchase = Purchase.createFromToken(purchaseToken);\n        // kick off the async query\n        mHelper.consumeAsync(purchase, mConsumeFinishedListener);\n    }\n\n    // Called when consumption is complete\n    IabHelper.OnConsumeFinishedListener mConsumeFinishedListener = new IabHelper.OnConsumeFinishedListener() {\n        public void onConsumeFinished(Purchase purchase, IabResult result) {\n            Log.d(TAG, \"Consumption finished. Purchase: \" + purchase + \", result: \" + result);\n            safe_native_CONSUME_CALLBACK(result);\n        }\n    };   \n    \n    /* Our native callbacks\n     * Below is the C++ format for reference\n     * void JNICALL s3e_ANDROIDGOOGLEPLAYBILLING_PURCHASE_CALLBACK( JNIEnv* env,  jobject obj, jint status, jstring errorMsg, jobject purchaseData);\n	 * void JNICALL s3e_ANDROIDGOOGLEPLAYBILLING_LIST_PRODUCTS_CALLBACK( JNIEnv* env,  jobject obj, jint status, jstring errorMsg, jobjectArray products);\n	 * void JNICALL s3e_ANDROIDGOOGLEPLAYBILLING_RESTORE_CALLBACK( JNIEnv* env,  jobject obj, jint status, jstring errorMsg, jobjectArray purchases);\n	 * void JNICALL s3e_ANDROIDGOOGLEPLAYBILLING_CONSUME_CALLBACK( JNIEnv* env,  jobject obj, jint status, jstring errorMsg\n     */\n\n    public static native void native_PURCHASE_CALLBACK(int status, String errorMsg, S3eBillingPurchase purchase);\n\n    public static native void native_LIST_PRODUCTS_CALLBACK(int status, String errorMsg, S3eBillingItemInfo[] skus);\n\n    public static native void native_RESTORE_CALLBACK(int status, String errorMsg, S3eBillingPurchase[] purchases);\n\n    public static native void native_CONSUME_CALLBACK(int status, String errorMsg);\n\n    // simple public classes for the Native C++ callbacks\n\n    public static class S3eBillingPurchase {\n        public String m_OrderID;\n        public String m_PackageID;\n        public String m_ProductId;\n        public long m_PurchaseTime;\n        public int m_PurchaseState;\n        public String m_PurchaseToken;\n        public String m_DeveloperPayload;\n        public String m_JSON;\n        public String m_Signature;\n\n        public S3eBillingPurchase(Purchase p) {\n            m_OrderID = p.getOrderId();\n            m_PackageID = p.getPackageName();\n            m_ProductId = p.getSku();\n            m_PurchaseTime = p.getPurchaseTime();\n            m_PurchaseState = p.getPurchaseState();\n            m_PurchaseToken = p.getToken();\n            m_DeveloperPayload = p.getDeveloperPayload();\n            m_JSON = p.getOriginalJson();\n            m_Signature = p.getSignature();\n        }\n    }\n\n    ;\n\n    public static class S3eBillingItemInfo {\n        public String m_ProductID;\n        public String m_Type;\n        public String m_Price;\n        public String m_Title;\n        public String m_Description;\n\n        public S3eBillingItemInfo(SkuDetails s) {\n            m_ProductID = s.getSku();\n            m_Type = s.getType();\n            m_Price = s.getPrice();\n            m_Title = s.getTitle();\n            m_Description = s.getDescription();\n        }\n\n        ;\n    }\n\n    ;\n\n    // Note, these are private static so they can be accessed from within the static nested Activity\n\n    private static void safe_native_PURCHASE_CALLBACK(IabResult res, Purchase purchase) {\n        // apparently there's no way to check if the JNI has bound this native function other than catch it\n        try {\n            S3eBillingPurchase p = null;\n            if (purchase != null)\n                p = new S3eBillingPurchase(purchase);\n            native_PURCHASE_CALLBACK(res.getResponse(), res.getMessage(), p);\n        } catch (UnsatisfiedLinkError e) {\n            Log.v(TAG, \"No native handlers installed for safe_native_PURCHASE_CALLBACK, we received \" + res.getResponse() + \" \" + res.getMessage());\n        }\n    }\n\n    private static void safe_native_LIST_PRODUCTS_CALLBACK(IabResult res, Inventory inv) {\n        // apparently there's no way to check if the JNI has bound this native function other than catch it\n        try {\n            if (inv != null) {\n                List<SkuDetails> skus = inv.getAllSkus();\n                S3eBillingItemInfo[] s = new S3eBillingItemInfo[skus.size()];\n                for (int i = 0; i < skus.size(); i++)\n                    s[i] = new S3eBillingItemInfo(skus.get(i));\n                native_LIST_PRODUCTS_CALLBACK(res.getResponse(), res.getMessage(), s);\n            } else\n                native_LIST_PRODUCTS_CALLBACK(res.getResponse(), res.getMessage(), null);\n        } catch (UnsatisfiedLinkError e) {\n            Log.v(TAG, \"No native handlers installed for native_LIST_PRODUCTS_CALLBACK, we received \" + res.getResponse() + \" \" + res.getMessage());\n        }\n    }\n\n    private static void safe_native_RESTORE_CALLBACK(IabResult res, Inventory inv) {\n        // apparently there's no way to check if the JNI has bound this native function other than catch it\n        try {\n            if (inv != null) {\n                List<Purchase> purchases = inv.getAllPurchases();\n                S3eBillingPurchase[] p = new S3eBillingPurchase[purchases.size()];\n                for (int i = 0; i < purchases.size(); i++)\n                    p[i] = new S3eBillingPurchase(purchases.get(i));\n                native_RESTORE_CALLBACK(res.getResponse(), res.getMessage(), p);\n            } else\n                native_RESTORE_CALLBACK(res.getResponse(), res.getMessage(), null);\n        } catch (UnsatisfiedLinkError e) {\n            Log.v(TAG, \"No native handlers installed for native_LIST_PRODUCTS_CALLBACK, we received \" + res.getResponse() + \" \" + res.getMessage());\n        }\n    }\n\n    private static void safe_native_CONSUME_CALLBACK(IabResult res) {\n        // apparently there's no way to check if the JNI has bound this native function other than catch it\n        try {\n            native_CONSUME_CALLBACK(res.getResponse(), res.getMessage());\n\n        } catch (UnsatisfiedLinkError e) {\n            Log.v(TAG, \"No native handlers installed for native_LIST_PRODUCTS_CALLBACK, we received \" + res.getResponse() + \" \" + res.getMessage());\n        }\n    }\n\n}\n",
			"file": "/Z/Projects/OpenIAB-fork/marmalade_plugin/source/android/org/onepf/marmalade/s3eOpenIab/s3eOpenIab.java",
			"file_size": -1,
			"file_write_time": -1,
			"settings":
			{
				"buffer_size": 14129,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "#!/usr/bin/env mkb\n# Builder mkb file for the java portion of the s3eOpenIab extension on android\nplatform JAVA\n\nfiles\n{\n    (source/android/org/onepf/marmalade/s3eOpenIab)\n    s3eOpenIab.java\n	PurchaseProxy.java\n}\n\nlibrarypath \"$MARMALADE_ROOT/s3e/deploy/plugins/android/android.jar\"\nlibrarypath \"$MARMALADE_ROOT/s3e/loader/android/s3e_release.jar\"\nlibrarypath \"../bin/openiab-amazon.jar\"\n\noption output-name=lib/android/s3eOpenIab.jar\n",
			"file": "/Z/Projects/OpenIAB-fork/marmalade_plugin/s3eOpenIab_android_java.mkb",
			"file_size": -1,
			"file_write_time": -1,
			"settings":
			{
				"buffer_size": 437,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "/*\nGeneric implementation of the s3eOpenIab extension.\nThis file should perform any platform-indepedentent functionality\n(e.g. error checking) before calling platform-dependent implementations.\n*/\n\n/*\n * NOTE: This file was originally written by the extension builder, but will not\n * be overwritten (unless --force is specified) and is intended to be modified.\n */\n\n#include \"s3eOpenIab_internal.h\"\ns3eResult s3eOpenIabInit()\n{\n    //Add any generic initialisation code here\n    return s3eOpenIabInit_platform();\n}\n\nvoid s3eOpenIabTerminate()\n{\n    //Add any generic termination code here\n    s3eOpenIabTerminate_platform();\n}\n\nvoid s3eOpenIabStart(s3eOpenIabOptions* options)\n{\n	s3eOpenIabStart_platform(options);\n}\n\nvoid s3eOpenIabStop()\n{\n	s3eOpenIabStop_platform();\n}\n\ns3eResult s3eOpenIabIsSupported()\n{\n	return s3eOpenIabIsSupported_platform();\n}\n\nvoid s3eOpenIabRequestPurchase(const char* productID, bool inApp, const char* developerPayLoad)\n{\n	s3eOpenIabRequestPurchase_platform(productID, inApp, developerPayLoad);\n}\n\nvoid s3eOpenIabRequestProductInformation(const char** inAppProducts, int numInAppProducts, const char** subProducts, int numSubProducts)\n{\n	s3eOpenIabRequestProductInformation_platform(inAppProducts, numInAppProducts, subProducts, numSubProducts);\n}\n\nvoid s3eOpenIabRestoreTransactions()\n{\n	s3eOpenIabRestoreTransactions_platform();\n}\n\nvoid s3eOpenIabConsumeItem(const char* purchaseToken)\n{\n	s3eOpenIabConsumeItem_platform(purchaseToken);\n}\n\ns3eOpenIabStoreNames* s3eOpenIabGetStoreNames()\n{\n	return s3eOpenIabGetStoreNames_platform();\n}\n\nvoid s3eOpenIabMapSku(const char* sku, const char* storeName, const char* storeSku)\n{\n	s3eOpenIabMapSku_platform(sku, storeName, storeSku);\n}\n",
			"file": "/Z/Projects/OpenIAB-fork/marmalade_plugin/source/generic/s3eOpenIab.cpp",
			"file_size": -1,
			"file_write_time": -1,
			"settings":
			{
				"buffer_size": 1711,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "options\n{\n	# Define COCOS2DX_ROOT env variable or set path to the Cocos2d-x library root folder\n	module_path=\"$COCOS2DX_ROOT/cocos2dx/proj.marmalade/;$COCOS2DX_ROOT/CocosDenshion/proj.marmalade/\"\n	s3e-data-dir = \"../Resources/\"\n}\n\nincludepaths\n{\n	../Classes\n}\n\nsubprojects\n{\n	IwGL\n	cocos2dx\n	CocosDenshion\n	../../s3eOpenIab.mkf\n}\n\nassets\n{\n	(../Resources)\n	.\n}\n\nfiles\n{\n	[Main]\n	(src)\n	Main.h\n	Main.cpp\n\n	(../Classes)\n	AppDelegate.h\n	AppDelegate.cpp\n	GameOverScene.cpp\n	GameOverScene.h\n	HelloWorldScene.cpp\n	HelloWorldScene.h\n	ShopScene.cpp\n	ShopScene.h\n}\n\ndeployments\n{\n	[\"Default\"]\n	android-manifest='AndroidManifest.xml'\n	name=\"openiab-marmalade-cocos-demo\"\n	caption=\"OpenIAB Marmalade Game\"\n	version-major=0\n	version-minor=0\n	version-revision=1\n	android-pkgname='org.onepf.marmalade.cocos.demo'\n}",
			"file": "/Z/Projects/OpenIAB-fork/marmalade_plugin/Cocos2d-x_SimpleGame/proj.marmalade/SimpleGame.mkb",
			"file_size": -1,
			"file_write_time": -1,
			"settings":
			{
				"buffer_size": 800,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/Z/Projects/OpenIAB-fork/build.xml",
			"settings":
			{
				"buffer_size": 3757,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/Z/Projects/OpenIAB-fork/unity_plugin/ant.properties",
			"settings":
			{
				"buffer_size": 785,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/Z/nvc-mining.bat",
			"settings":
			{
				"buffer_size": 150,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/Z/Sprites-Diffuse.shader",
			"settings":
			{
				"buffer_size": 1136,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Z/Projects/UrbanSurvival/.gitignore",
			"settings":
			{
				"buffer_size": 154,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "/**\n* @page This Application demonstrates usage of the Android Google Play Billing Marmalade extension.\n* The application is intended to be functional and demonstrate how to use the extension code without the distraction of complex UI.\n*/\n\n#include \"s3eOpenIab.h\"\n#include \"IwDebug.h\"\n#include \"s3e.h\"\n#include \"IwNUI.h\"\n#include \"IwRandom.h\"\n\n#include \"ExampleUI.h\"\n//#include \"UnitTests.h\"\n#include <IwPropertyString.h>\n#include \"s3eDebug.h\"\n\n//UnitTests *gTests;\n\n// Button click handlers for the UI\n\nconst char *inAppSkus[] =\n{\n	\"sku_hat_inner\",\n	\"sku_coin_inner\"\n};\n\nconst char *subSkus[] = \n{\n	\"sku_subs_inner\"\n};\n\n// Query Shop\nbool OnButton1Click(void* data, CButton* button)\n{\n	ExampleUI *ui = (ExampleUI*)data;\n	ui->Log(\"Query Shop Items\");\n	s3eOpenIabRequestProductInformation(inAppSkus,sizeof(inAppSkus)/sizeof(const char*),subSkus,sizeof(subSkus)/sizeof(const char*));\n	return true;\n}\n\n// Restore Purchases\nbool OnButton2Click(void* data, CButton* button)\n{\n	ExampleUI *ui = (ExampleUI*)data;\n	ui->Log(\"Attempting to Restore Purchases\");\n	s3eOpenIabRestoreTransactions();\n\n	return true;\n}\n\n// Purchase a Hat\nbool OnButton3Click(void* data, CButton* button)\n{\n	ExampleUI *ui = (ExampleUI*)data;\n	ui->Log(\"Attempting to purchase Hat\");\n	string randomPayload = string_format(\"TestPayload%d\",IwRandMinMax(1,10000)); // let's be clear this is a test - in your code either don't set it or use something sensible you can check later on a different device\n	s3eOpenIabRequestPurchase(inAppSkus[0],true,randomPayload.c_str());\n\n	return true;\n}\n\nstring purchasedConsumableID;\n\n// Purchase a Coin\nbool OnButton4Click(void* data, CButton* button)\n{\n	ExampleUI *ui = (ExampleUI*)data;\n	ui->Log(\"Attempting to purchase Coin\");\n	string randomPayload = string_format(\"TestPayload%d\",IwRandMinMax(1,10000));\n	s3eOpenIabRequestPurchase(inAppSkus[1],true,randomPayload.c_str());\n\n	return true;\n}\n\n// Purchase a Subscription\nbool OnButton5Click(void* data, CButton* button)\n{\n	ExampleUI *ui = (ExampleUI*)data;\n	ui->Log(\"Attempting to purchase Subscription\");\n	string randomPayload = string_format(\"TestPayload%d\",IwRandMinMax(1,10000));\n	s3eOpenIabRequestPurchase(subSkus[0],false,randomPayload.c_str());\n\n	return true;\n}\n\nvoid ConsumeCoin(void* data)\n{\n	ExampleUI *ui = (ExampleUI*)data;\n	ui->Log(\"Attempting to consume Coin\");\n	if (purchasedConsumableID.length() == 0)\n		ui->Log(\"Error: no item to consume, try Restore if you restarted the Example app\");\n	else\n		s3eOpenIabConsumeItem(purchasedConsumableID.c_str());\n}\n\nint32 ListCallback(void *systemData,void *userData)\n{\n	if ((systemData) && (userData))\n	{\n		ExampleUI* ui = (ExampleUI*)userData; // this is a pointer passed through from when the callback was registered\n		s3eOpenIabSkuResponse *skus = (s3eOpenIabSkuResponse*)systemData;\n		string str;\n		if (skus->m_ErrorMsg) {\n			str = string_format(\"List Sku returned : %d, %s\", (int)skus->m_Status, skus->m_ErrorMsg);\n			ui->Log(str);\n		}\n		if (skus->m_Status == S3E_OPENIAB_RESULT_OK)\n		{\n			str = string_format(\"%d items returned\",skus->m_NumProducts);\n			ui->Log(str);\n			for (int i=0;i<skus->m_NumProducts;i++)\n			{\n				ui->Log(\"{\");\n				s3eOpenIabItemInfo *item = &skus->m_Products[i];\n				ui->Log(string_format(\"	m_ProductID		: %s\",item->m_ProductID));\n				ui->Log(string_format(\"	m_Type			: %s\",item->m_Type));\n				ui->Log(string_format(\"	m_Price			: %s\",item->m_Price));\n				ui->Log(string_format(\"	m_Title			: %s\",item->m_Title));\n				ui->Log(string_format(\"	m_Description	: %s\",item->m_Description));\n				ui->Log(\"}\");\n			}\n		}\n	}\n	return true;\n}\n\nint32 RestoreCallback(void *systemData,void *userData)\n{\n	if ((systemData) && (userData))\n	{\n		ExampleUI* ui = (ExampleUI*)userData; // this is a pointer passed through from when the callback was registered\n		s3eOpenIabRestoreResponse *rr = (s3eOpenIabRestoreResponse*)systemData;\n		string str;\n		if (rr->m_ErrorMsg) {\n			str = string_format(\"Restore returned : %d, %s\", (int)rr->m_Status, rr->m_ErrorMsg);\n			ui->Log(str);\n		}\n		if (rr->m_Status == S3E_OPENIAB_RESULT_OK)\n		{\n			str = string_format(\"%d items returned\",rr->m_NumPurchases);\n			ui->Log(str);\n			for (int i=0;i<rr->m_NumPurchases;i++)\n			{\n				ui->Log(\"{\");\n				s3eOpenIabPurchase *item = &rr->m_Purchases[i];\n				ui->Log(string_format(\"	m_OrderID			: %s\",item->m_OrderID));\n				ui->Log(string_format(\"	m_PackageID			: %s\",item->m_PackageID));\n				ui->Log(string_format(\"	m_ProductId			: %s\",item->m_ProductId));\n				ui->Log(string_format(\"	m_PurchaseTime		: %d\",item->m_PurchaseTime));\n				ui->Log(string_format(\"	m_PurchaseState		: %d\",item->m_PurchaseState));\n				ui->Log(string_format(\"	m_PurchaseToken		: %s\",item->m_PurchaseToken));				\n				ui->Log(string_format(\"	m_DeveloperPayload	: %s\",item->m_DeveloperPayload));				\n				ui->Log(string_format(\"	m_JSON				: %s\",item->m_JSON));\n				ui->Log(string_format(\"	m_Signature			: %s\",item->m_Signature));\n				ui->Log(\"}\");\n\n				if (strcmp(inAppSkus[0], item->m_ProductId) == 0)\n				{\n					ui->buttons[2]->SetAttribute(\"enabled\", false);\n				} \n				else if (strcmp(inAppSkus[1], item->m_ProductId) == 0)\n				{\n					purchasedConsumableID = item->m_PurchaseToken;\n					ui->SetConsumableText(purchasedConsumableID);\n					ui->buttons[3]->SetAttribute(\"enabled\", false);\n					ConsumeCoin(userData);\n				} \n				else if (strcmp(subSkus[0], item->m_ProductId) == 0) \n				{\n					ui->buttons[4]->SetAttribute(\"enabled\", false);\n				}\n			}\n		}\n	}\n	return true;\n}\n\nint32 PurchaseCallback(void *systemData,void *userData)\n{\n	if ((systemData) && (userData))\n	{\n		ExampleUI* ui = (ExampleUI*)userData; // this is a pointer passed through from when the callback was registered\n		s3eOpenIabPurchaseResponse *pr = (s3eOpenIabPurchaseResponse*)systemData;\n		string str;\n		if (pr->m_ErrorMsg) {\n			str = string_format(\"Purchase returned : %d, %s\", (int)pr->m_Status, pr->m_ErrorMsg);\n			ui->Log(str);\n		}\n		if (pr->m_Status == S3E_OPENIAB_RESULT_OK)\n		{\n			s3eOpenIabPurchase *item = pr->m_PurchaseDetails;\n			ui->Log(string_format(\"	m_OrderID			: %s\",item->m_OrderID));\n			ui->Log(string_format(\"	m_PackageID			: %s\",item->m_PackageID));\n			ui->Log(string_format(\"	m_ProductId			: %s\",item->m_ProductId));\n			ui->Log(string_format(\"	m_PurchaseTime		: %d\",item->m_PurchaseTime));\n			ui->Log(string_format(\"	m_PurchaseState		: %d\",item->m_PurchaseState));\n			ui->Log(string_format(\"	m_PurchaseToken		: %s\",item->m_PurchaseToken));				\n			ui->Log(string_format(\"	m_DeveloperPayload	: %s\",item->m_DeveloperPayload));				\n			ui->Log(string_format(\"	m_JSON				: %s\",item->m_JSON));\n			ui->Log(string_format(\"	m_Signature			: %s\",item->m_Signature));\n\n			if (strcmp(inAppSkus[0], item->m_ProductId) == 0)\n			{\n				ui->buttons[2]->SetAttribute(\"enabled\", false);\n			} \n			else if (strcmp(inAppSkus[1], item->m_ProductId) == 0)\n			{\n				purchasedConsumableID = item->m_PurchaseToken;\n				ui->SetConsumableText(purchasedConsumableID);\n				ui->buttons[3]->SetAttribute(\"enabled\", false);\n				ConsumeCoin(userData);\n			} \n			else if (strcmp(subSkus[0], item->m_ProductId) == 0) \n			{\n				ui->buttons[4]->SetAttribute(\"enabled\", false);\n			}\n		}\n	}\n	return true;\n}\n\nint32 ConsumeCallback(void *systemData,void *userData)\n{\n	if ((systemData) && (userData))\n	{\n		ExampleUI* ui = (ExampleUI*)userData; // this is a pointer passed through from when the callback was registered\n		s3eOpenIabConsumeResponse *cr = (s3eOpenIabConsumeResponse*)systemData;\n		string str;\n		if (cr->m_ErrorMsg) {\n			str = string_format(\"Purchase returned : %d, %s\", (int)cr->m_Status, cr->m_ErrorMsg);\n			ui->Log(str);\n		}\n		if (cr->m_Status == S3E_OPENIAB_RESULT_OK) {\n			ui->SetConsumableText(\"None\");\n		}\n		ui->buttons[3]->SetAttribute(\"enabled\", true);\n	}	\n	return true;\n}\n\n// note this is the public license key provided by Google, not the one you sign this app with, it's in the developer console under Services & APIs\n\nconst char *publicKey = \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApe2d3t+F+v1C5OUGPNW2+au8kyf2jAeK9QDg1MpFKgk9x+zh/ye/Y7JAv3gCVPb31CWTemywQLLRosm/DmqOFkPqMuexyKzm72X9cKbLupUI3iPXyASKh92R2+/p25iFRLKdWijh/ESkk0ii3PDBg3RIqjswlYiQ7g4SQ3YeVw+sOTyTIGik+yqz8bR7WEKbbFdsGMTUFwPgn273itimYMQ7vH6WtkCTzo5z1+Ab8DIygx6hCqKCvKOEDRBFB8/rJ7pl4jJsCsQHV5Q0x98fBN0Y9+jtKD0+M5Sm/u2+kNIukFF4khbBhdqisfL/8bbTsxE68tYh2GWWv10MqSv7JQIDAQAB\";\n//const char *publicKey = \"Put your public key here / if you dont do this / payments will succeed but the extension will still report them as having failed / also this string needs to be Base64 clean\";\n\nint main()\n{\n	char animatingText[] = \"... Some Animating Text ...\";\n	uint64 animatingTextTimer;\n\n	// seed RNG\n	int32 ms = (int32)s3eTimerGetMs();\n	IwRandSeed(ms);\n\n	// create our Marmalade UI interface\n	ExampleUI *ui = new ExampleUI(); \n	ui->Log(\"main()\");\n	//ui->EnableAllButtons(false);\n\n	s3eOpenIabStoreNames* storeNames = s3eOpenIabGetStoreNames();\n\n	// Map SKUs\n	s3eOpenIabMapSku(inAppSkus[0], storeNames->m_GooglePlay, \"sku_hat\");\n	s3eOpenIabMapSku(inAppSkus[1], storeNames->m_GooglePlay, \"sku_coin\");\n	s3eOpenIabMapSku(subSkus[0], storeNames->m_GooglePlay, \"sku_subs\");\n\n	// Options\n	s3eOpenIabOptions* options = new s3eOpenIabOptions();\n\n	options->m_NumStores = 1;\n	options->m_StoreNames = new const char*[options->m_NumStores];\n	options->m_StoreKeys = new const char*[options->m_NumStores];\n	options->m_StoreNames[0] = storeNames->m_GooglePlay;\n	options->m_StoreKeys[0] = publicKey;\n\n	options->m_VerifyMode = VERIFY_SKIP;\n\n	options->m_CheckInventory = false;\n\n	options->m_CheckInventoryTimeoutMs = 20000;\n\n	options->m_DiscoveryTimeoutMs = 10000;\n\n	options->m_NumPrefferedStoreNames = 1;\n	options->m_PrefferedStoreNames = new const char*[options->m_NumPrefferedStoreNames];\n	options->m_PrefferedStoreNames[0] = storeNames->m_GooglePlay;\n\n	options->m_SamsungCertificationRequestCode = REQUEST_CODE_IS_IAP_PAYMENT;\n\n	// Start up the Store interface\n	s3eOpenIabStart(options);\n\n	// register callbacks and pass in our UI pointer which the callback\n	s3eOpenIabRegister(S3E_OPENIAB_LIST_PRODUCTS_CALLBACK,ListCallback,ui); \n	s3eOpenIabRegister(S3E_OPENIAB_RESTORE_CALLBACK,RestoreCallback,ui); \n	s3eOpenIabRegister(S3E_OPENIAB_PURCHASE_CALLBACK,PurchaseCallback,ui); \n	s3eOpenIabRegister(S3E_OPENIAB_CONSUME_CALLBACK,ConsumeCallback,ui);\n\n	ui->SetStatusText((s3eOpenIabIsSupported())?\"Initialised\":\"Unitialised\");\n\n	// create the Unit Test singleton\n	//gTests = new UnitTests(ui); // DH: Not implemented for this extension yet\n\n	animatingTextTimer = s3eTimerGetMs();\n\n	// run the app\n	while (1)\n	{\n		//gTests->Update(); // update the tests if they're running\n\n		//s3eOpenIabIsSupported()\n\n		// animate the text\n		if (s3eTimerGetMs() > animatingTextTimer + 20)\n		{\n			int len = strlen(animatingText);\n			char c = animatingText[0];\n			memmove(animatingText,animatingText+1,len-1);\n			animatingText[len-1] = c;\n			ui->SetAnimatingText(animatingText);\n			animatingTextTimer = s3eTimerGetMs();\n		}\n\n		//ui->SetStatusText((s3eOpenIabIsSupported())?\"Initialised\":\"Unitialised\"); // annoying log spam\n		ui->Update(); // update the UI\n		s3eDeviceYield();\n	}\n\n	return 0;\n}\n",
			"file": "s3eOpenIabDemo.cpp",
			"file_size": -1,
			"file_write_time": -1,
			"settings":
			{
				"buffer_size": 11030,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 311.0,
		"selected_items":
		[
			[
				"Package Control: ",
				"Package Control: Disable Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"enable",
				"Package Control: Enable Package"
			],
			[
				"",
				"Package Control: Install Package"
			]
		],
		"width": 400.0
	},
	"console":
	{
		"height": 539.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/Z/Projects/OpenIAB-fork/marmalade_plugin/source/android/s3eOpenIab_platform.cpp",
		"/Z/Projects/OpenIAB-fork/marmalade_plugin/ExampleApplication/s3eOpenIabDemo.mkb",
		"/Z/Projects/OpenIAB-fork/marmalade_plugin/ExampleApplication/AndroidManifest.xml",
		"/Z/Projects/OpenIAB-fork/marmalade_plugin/Cocos2d-x_SimpleGame/proj.marmalade/AndroidManifest.xml",
		"/Z/Projects/OpenIAB-fork/marmalade_plugin/source/android/org/onepf/marmalade/s3eOpenIab/s3eOpenIab.java",
		"/Z/nvc-mining.bat",
		"/Z/Projects/OpenIAB-fork/marmalade_plugin/source/generic/s3eOpenIab.cpp",
		"/Z/Projects/OpenIAB-fork/marmalade_plugin/ExampleApplication/marmalade_plugin.sublime-project",
		"/C/dev/cocos2d-x/cocos2d-x-2.2.2/samples/Cpp/SimpleGame/Classes/AppDelegate.cpp",
		"/C/dev/cocos2d-x/cocos2d-x-2.2.2/samples/Cpp/SimpleGame/proj.marmalade/SimpleGame.mkb",
		"/Z/Projects/OpenIAB-fork/marmalade_plugin/Cocos2d-x_SimpleGame/proj.marmalade/SimpleGame.mkb",
		"/C/dev/cocos2d-x/cocos2d-x-2.2.2/samples/Cpp/SimpleGame/Resources/app.config.txt",
		"/Z/Projects/OpenIAB-fork/marmalade_plugin/s3eOpenIab.s4e",
		"/Z/Projects/OpenIAB-fork/marmalade_plugin/source/generic/s3eOpenIab_register.cpp",
		"/C/Users/akarazhey/AppData/Roaming/Sublime Text 3/Packages/User/Package Control.sublime-settings",
		"/C/Users/akarazhey/AppData/Roaming/Sublime Text 3/Packages/Default/Preferences.sublime-settings",
		"/C/Users/akarazhey/AppData/Roaming/Sublime Text 3/Packages/Package Control/Package Control.sublime-settings",
		"/C/Users/akarazhey/AppData/Roaming/Sublime Text 3/Packages/User/C++.sublime-settings"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"callback",
			"s3eOpenIabStart",
			"s3eOpenIabStop",
			"stop",
			"s3eOpeniab",
			"makeStringArray",
			"FindClass",
			"options",
			"start",
			"options",
			"s3eOpenIabStart",
			"Delete",
			"delete",
			"options",
			"inAppSkus",
			"mapSku",
			"Call",
			"CallVoidMethod"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 2,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "/Z/Projects/OpenIAB-fork/marmalade_plugin/s3eOpenIab.s4e",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16022,
						"regions":
						{
						},
						"selection":
						[
							[
								11980,
								11980
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 5518.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 1,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 166,
						"regions":
						{
						},
						"selection":
						[
							[
								166,
								0
							]
						],
						"settings":
						{
							"auto_name": "Don't need to extend BillingActivity anymore.",
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "/Z/Projects/OpenIAB-fork/unity_plugin/unity_src/.gitignore",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 49,
						"regions":
						{
						},
						"selection":
						[
							[
								49,
								49
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "/Z/Projects/OpenIAB-fork/marmalade_plugin/source/android/org/onepf/marmalade/s3eOpenIab/s3eOpenIab.java",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14129,
						"regions":
						{
						},
						"selection":
						[
							[
								2300,
								2300
							]
						],
						"settings":
						{
							"syntax": "Packages/Java/Java.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2406.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/Z/Projects/OpenIAB-fork/marmalade_plugin/s3eOpenIab_android_java.mkb",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 437,
						"regions":
						{
						},
						"selection":
						[
							[
								389,
								389
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "/Z/Projects/OpenIAB-fork/marmalade_plugin/source/generic/s3eOpenIab.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1711,
						"regions":
						{
						},
						"selection":
						[
							[
								755,
								755
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/Z/Projects/OpenIAB-fork/marmalade_plugin/Cocos2d-x_SimpleGame/proj.marmalade/SimpleGame.mkb",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 800,
						"regions":
						{
						},
						"selection":
						[
							[
								563,
								564
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "/Z/Projects/OpenIAB-fork/build.xml",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3757,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/XML/XML.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "/Z/Projects/OpenIAB-fork/unity_plugin/ant.properties",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 785,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Java/JavaProperties.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "/Z/nvc-mining.bat",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 150,
						"regions":
						{
						},
						"selection":
						[
							[
								150,
								150
							]
						],
						"settings":
						{
							"syntax": "Packages/Batch File/Batch File.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "/Z/Sprites-Diffuse.shader",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1136,
						"regions":
						{
						},
						"selection":
						[
							[
								675,
								675
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "/Z/Projects/UrbanSurvival/.gitignore",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 154,
						"regions":
						{
						},
						"selection":
						[
							[
								154,
								154
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "s3eOpenIabDemo.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11030,
						"regions":
						{
						},
						"selection":
						[
							[
								2566,
								2566
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1024.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"project": "marmalade_plugin.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 282.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
